[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/DmV0TD24)
# Actividad: Desarrollo de Proyecto Software en Kotlin

**ID actividad:** 2425_PRO_u4u5u6_libre

**Agrupamiento de la actividad**: Individual 

---

### Descripción:

La actividad consiste en el desarrollo de un proyecto software en Kotlin, permitiendo al estudiante elegir la temática. Este proyecto debe demostrar la comprensión y aplicación de los conceptos de programación orientada a objetos (POO), incluyendo el uso y manejo de estructuras de datos complejas, la definición y uso de clases, herencia, interfaces, genericos, expresiones regulares, principios SOLID y el uso de librerías externas.

**Objetivo:**

- Demostrar comprensión de los fundamentos de POO mediante la instanciación y uso de objetos.
- Aplicar conceptos avanzados de POO como herencia, clases abstractas, e interfaces.
- Crear y usar clases que hagan uso de genéricos. 
- Aplicar principios SOLID.
- Hacer uso de las expresiones regulares.
- Integrar y utilizar librerías de clases externas para extender la funcionalidad del proyecto.
- Documentar y presentar el código de manera clara y comprensible.

**Trabajo a realizar:**

1. **Selección de la Temática:** Elige un tema de tu interés que pueda ser abordado mediante una aplicación software. Esto podría ser desde una aplicación de gestión para una pequeña empresa, una herramienta para ayudar en la educación, hasta un juego simple. Define claramente el problema que tu aplicación pretende resolver.

2. **Planificación:** Documenta brevemente cómo tu aplicación solucionará el problema seleccionado, incluyendo las funcionalidades principales que desarrollarás.

3. **Desarrollo:**
   - **Instancia de Objetos:** Tu aplicación debe crear y utilizar objetos, demostrando tu comprensión de la instanciación y el uso de constructores, métodos, y propiedades.
   - **Métodos Estáticos:** Define y utiliza al menos un método estático, explicando por qué es necesario en tu aplicación.
   - **Uso de IDE:** Desarrolla tu proyecto utilizando un IDE, aprovechando sus herramientas para escribir, compilar, y probar tu código.
   - **Definición de Clases:** Crea clases personalizadas con sus respectivas propiedades, métodos, y constructores.
   - **Clases con genéricos:** Define y utiliza al menos una clase que haga uso de genéricos en tu aplicación.
   - **Herencia y Polimorfismo:** Implementa herencia y/o interfaces en tu proyecto para demostrar la reutilización de código y la flexibilidad de tu diseño.  **Usa los principios SOLID:** Ten presente durante el desarrollo los principios SOLID y úsalos durante el diseño para mejorar tu aplicación.
   - **Librerías de Clases:** Integra y utiliza una o más librerías externas que enriquezcan la funcionalidad de tu aplicación.
   - **Documentación:** Comenta tu código de manera efectiva, facilitando su comprensión y mantenimiento.

4. **Prueba y Depuración:** Realiza pruebas para asegurarte de que tu aplicación funciona como se espera y depura cualquier error encontrado.
5. **Contesta a las preguntas** Ver el punto **Preguntas para la Evaluación**

### Recursos

- Apuntes dados en clase sobre programación orientada a objetos, Kotlin, uso de IDEs, y manejo de librerías.
- Recursos vistos en clase, incluyendo ejemplos de código, documentación de Kotlin, y guías de uso de librerías.

### Evaluación y calificación

**RA y CE evaluados**: Resultados de Aprendizaje 2, 4, 6, 7 y Criterios de Evaluación asociados.

**Conlleva presentación**: SI

**RÚbrica**: Más adelante se enviará o mostrará la rúbrica de esta práctica.

### Entrega

> **La entrega tiene que cumplir las condiciones de entrega para poder ser calificada. En caso de no cumplirlas podría calificarse como no entregada.**
>
- **Conlleva la entrega de URL a repositorio:** El contenido se entregará en un repositorio GitHub. 
- **Respuestas a las preguntas:** Deben contestarse, de manera clara y detallada en este fichero, README.md

    - Al final del documento, incluid un nuevo apartado, que se llame: "Entrega de la Práctica", dónde nos realicéis una pequeña introducción explicativa de vuestro tema, es decir, el problema que vais a solucionar y cómo lo habéis resuelto. Podéis incluir los subapartados que consideréis necesarios (estructura de carpetas, explicación y organización de clases, instrucciones de instalación, manual de usuario, ejemplos de funcionamiento, etc.)

    - **MUY IMPORTANTE!!** Incluir un subapartado ("Respuestas a las preguntas planteadas") dónde se resuelvan las preguntas de evaluación que os realizamos a continuación. De forma clara y detallada, incluyendo enlaces al código que justifica vuestra respuesta si es necesario.

# Preguntas para la Evaluación

Este conjunto de preguntas está diseñado para ayudarte a reflexionar sobre cómo has aplicado los criterios de evaluación en tu proyecto. Al responderlas, **asegúrate de hacer referencia y enlazar al código relevante** en tu `README.md`, facilitando así la evaluación de tu trabajo.

#### **Criterio global 1: Instancia objetos y hacer uso de ellos**
- **(2.a, 2.b, 2.c, 2.d, 2.f, 2.h, 4.e, 4.f)**: Describe cómo has instanciado y utilizado objetos en tu proyecto. ¿Cómo has aplicado los constructores y pasado parámetros a los métodos? Proporciona ejemplos específicos de tu código.

#### **Criterio global 2: Crear y llamar métodos estáticos**
- **(4.h)**: ¿Has definido algún método/propiedad estático en tu proyecto? ¿Cuál era el objetivo y por qué consideraste que debía ser estático en lugar de un método/propiedad de instancia?
- **(2.e)**: ¿En qué parte del código se llama a un método estático o se utiliza la propiedad estática?

#### **Criterio global 3: Uso de entornos**
- **(2.i)**: ¿Cómo utilizaste el IDE para el desarrollo de tu proyecto? Describe el proceso de creación, compilación, y prueba de tu programa.

#### **Criterio global 4: Definir clases y su contenido**
- **(4.a, 4.b, 4.c, 4.d, 4.g)**: Explica sobre un ejemplo de tu código, cómo definiste las clases en tu proyecto, es decir como identificaste las de propiedades, métodos y constructores y modificadores del control de acceso a métodos y propiedades, para representar al objeto del mundo real. ¿Cómo contribuyen estas clases a la solución del problema que tu aplicación aborda?

#### **Criterio global 5: Herencia y uso de clases abstractas e interfaces**
- **(4.g, 7.a, 7.b, 7.c, 7.i, 7.j)**: Describe sobre tu código cómo has implementado la herencia y/o utilizado interfaces en tu proyecto. ¿Por qué elegiste este enfoque y cómo beneficia a la estructura de tu aplicación? ¿De qué manera has utilizado los principios SOLID para mejorar el diseño de tu proyecto? Mostrando tu código, contesta qué principios has utilizado y qué beneficio has obtenido.

#### **Criterio global 6: Diseño de jerarquía de clases**
- **(7.d, 7.e, 7.f, 7.g)**: Presenta la jerarquía de clases que diseñaste. ¿Cómo probaste y depuraste esta jerarquía para asegurar su correcto funcionamiento? ¿Qué tipo de herencia has utilizado: Especificación, Especialización, Extensión, Construcción?

#### **Criterio global 7: Librerías de clases**
- **(2.g, 4.i)**: Describe cualquier librería externa que hayas incorporado en tu proyecto. Explica cómo y por qué las elegiste, y cómo las incorporaste en tu proyecto. ¿Cómo extendió la funcionalidad de tu aplicación? Proporciona ejemplos específicos de su uso en tu proyecto.

#### **Criterio global 8: Documentado**
- **(7.h)**: Muestra ejemplos de cómo has documentado y comentado tu código. ¿Que herramientas has utilizado? ¿Cómo aseguras que tu documentación aporte valor para la comprensión, mantenimiento y depuración del código?

#### **Criterio global 9: Genéricos**
- **(6.f)**: Muestra ejemplos de tu código sobre cómo has implementado una clase con genéricos. ¿Qué beneficio has obtenido?

#### **Criterio global 10: Expresiones Regulares**
- **(6.g)**: Muestra ejemplos de tu código donde hayas utilizado las expresiones regulares. ¿Qué beneficio has obtenido?

-----

### Descripción del Proyecto

El proyecto es un juego de mazmorras en consola titulado **"Mazmorras de Gunter: El Ascenso del Rey Demonio"**. El juego está diseñado para ofrecer una experiencia de aventura y combate por turnos, donde el jugador crea un personaje, explora mazmorras, lucha contra enemigos y gestiona su inventario.

### Planificación

El juego **"Mazmorras de Gunter: El Ascenso del Rey Demonio"** ofrece una experiencia de juego sencilla y desafiante en consola. A continuación, se describe cómo soluciona el problema y sus funcionalidades principales:

#### Cómo soluciona el problema:
- **Simplicidad**: Ejecutable en consola, sin necesidad de hardware avanzado.
- **Progresión clara**: Avance por mazmorras y mejora del personaje.
- **Estrategia**: Combate por turnos y gestión de inventario.

#### Funcionalidades principales:
1. **Creación de personajes**: Nombre personalizado y atributos iniciales.
2. **Exploración de mazmorras**: Mazmorras generadas proceduralmente con enemigos variados.
3. **Combate por turnos**: Ataque, defensa y uso de objetos.
4. **Gestión de inventario**: Recolección y uso de pociones, armas y escudos.
5. **Guardado y carga**: Partidas guardadas en formato JSON.
6. **Progresión**: Subida de nivel y mejora de atributos.

### Respuesta a las preguntas

1. Criterio global 1

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/3245c0dbb0d7113324fa60223f9c3dbca55659eb/src/main/kotlin/dominio/entidades/Personaje.kt#L108-L111

Por ejemplo en esta clase Personaje el constructor es privado y las instancias se crean con la funcion crearInstancia dentro del companion object, la cual crea una instancia con unos valores predeterminados y un nombre.

2. Criterio global 2

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/3245c0dbb0d7113324fa60223f9c3dbca55659eb/src/main/kotlin/dominio/entidades/Mazmorra.kt#L193-L203

Aqui e definido el metodo estático obtenerNivelMazmorra en la clase Mazmorra, este metodo elige el nivel de la mazmorra según el numero de mazmorras ya jugadas por el jugador.Considere hacerlo estatico para poder acceder a el sin la necesidad de crear una instancia.

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/3245c0dbb0d7113324fa60223f9c3dbca55659eb/src/main/kotlin/servicios/Consola.kt#L175-L180

Se utiliza en esta linea de codigo dentro de la clase Consola el cual utilizo para sacar el nivel correspondiente para luego crear una instancia de Mazmorra.

3. Criterio global 3

Para el proyecto utilice IntelliJ IDEA configurandolo para ser un proyecto con Gradle, organice el codigo en los paquetes dominio, servicios y presentacion. Para el desarrollo del proyecto, utilicé IntelliJ IDEA, aprovechando herramientas como autocompletado y refactorización para escribir código rápido y limpio. Integré librerías como kotlinx.serialization para la serialización de datos. Compilé el proyecto y lo ejecuté desde el IDE para probar el flujo del juego con el depurador para inspeccionar variables y corregir errores, despues con Git para gestionar commits y ramas. Además el codigo esta con KDoc para facilitar su mantenimiento y entendimiento.

5. Criterio global 4

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L19-L32

Defini clases como Personaje, Mazmorra y Enemigo para representar entidades del mundo real. Por ejemplo, la clase Personaje hereda de la clase abstracta entidad de la cual despues tambien hereda enemigo por su comportamiento similar, tiene propiedades como nombre, vidaMaxima, ataque, armadura, nivel, experiencia, inventario, enemigosEliminados, bossesEliminados, mazmorrasLimpiadas y rondasMazmorra, que permiten gestionar el estado del personaje durante el juego.

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L40
https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L59
https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L87
https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L108

Los métodos como atacar, usarObjeto y subirNivel permiten al personaje interactuar con el mundo del juego. El constructor privado asegura que solo se puedan crear instancias de Personaje a través del método estático crearInstancia, lo que garantiza un control sobre cómo se inicializan los objetos.

5. Criterio global 5

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L19-L32

La clase Personaje hereda de la clase abstracta Entidad, que define propiedades y métodos comunes como vida, ataque y armadura. Además, Personaje implementa la interfaz Combatiente, que define comportamientos como atacar

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/servicios/Combatiente.kt#L12-L20

Principio de Segregación de Interfaces (ISP): La interfaz Combatiente define solo los métodos necesarios para el combate, evitando que las clases implementen métodos que no usan.
La herencia permite reutilizar código entre clases como Personaje y Enemigo, mientras que las interfaces añaden flexibilidad para nuevos comportamientos. Los principios SOLID mejoran la mantenibilidad y extensión del código.
   
6. Criterio global 6

Diseñé una jerarquía de clases donde la clase abstracta Entidad es la base para Personaje y Enemigo. Entidad define propiedades y métodos comunes como vida, ataque y armadura, mientras que Personaje y Enemigo extienden esta funcionalidad con comportamientos específicos. Además, implementé la interfaz Combatiente para definir acciones como atacar, que son compartidas por ambas clases.
Utilicé herencia de especificación, ya que Entidad define un contrato común que Personaje y Enemigo implementan, asegurando que ambas clases compartan propiedades y métodos básicos.

Pruebas manuales: Ejecuté el juego y verifiqué el comportamiento de Personaje y Enemigo en combates y al usar objetos.
Depuración: Usé el depurador de IntelliJ IDEA para inspeccionar el estado de las variables y seguir el flujo del programa en métodos clave como atacar.

7. Criterio global 7

En el proyecto, incorporé la librería kotlinx.serialization para serializar y deserializar objetos, como los datos del personaje, en formato JSON. Esta librería fue elegida por su integración nativa con Kotlin y su facilidad de uso para convertir objetos en cadenas JSON y viceversa.
Añadí la dependencia en el archivo build.gradle.kts: implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.0")
Utilicé anotaciones como @Serializable en las clases que necesitaban ser serializadas, como PersonajeSerializable.
Guardado y carga de partidas: La librería permitió guardar el estado del personaje en un archivo JSON y cargarlo posteriormente, lo que añadió persistencia al juego.
Interoperabilidad: Facilitó el intercambio de datos entre diferentes partes del programa, como el menú principal y las mazmorras.

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/serializable/PersonajeSerializable.kt#L5-L34
   
8. Criterio global 8

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Personaje.kt#L4-L26

Para documentar el código, utilicé KDoc, el estándar de Kotlin, junto con comentarios claros y descriptivos, y herramientas como Dokka para generar documentación HTML. Aseguré la claridad explicando el propósito de cada clase, método o bloque de código, manteniendo consistencia con un formato estándar y actualizando la documentación junto con el código para garantizar su precisión. Esto, junto con la generación de documentación HTML, facilita la comprensión, mantenimiento y revisión del código para otros desarrolladores.
   
9. Criterio global 9

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/15689eacefa827dff551e6ad377242f59c647f5a/src/main/kotlin/dominio/entidades/Cofre.kt#L10-L28

Implementé genéricos en la clase Cofre<T>, que permite almacenar cualquier tipo de objeto. Esto proporciona flexibilidad, ya que el cofre puede contener desde pociones hasta armas, sin necesidad de crear múltiples clases para cada tipo de objeto.
Los genéricos proporcionan flexibilidad al permitir que el cofre almacene cualquier tipo de objeto, como pociones o armas. Mejoran la reutilización de código, evitando la creación de clases separadas para cada tipo.

10. Criterio global 10

https://github.com/IES-Rafael-Alberti/dawb1-2425-u4u5u6-libre-GunterMagno/blob/05f790cd742826fdba349efac66196a744994b00/src/main/kotlin/servicios/Consola.kt#L85-L94

Utilicé expresiones regulares para validar el nombre del personaje, asegurando que solo contenga letras y no caracteres especiales o números.
Esto mejora la experiencia del usuario al proporcionar retroalimentación inmediata y garantiza seguridad, evitando problemas derivados de caracteres no deseados.
